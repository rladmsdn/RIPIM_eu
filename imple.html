<!DOCTYPE html>

<html>
  <head>
    <title>RIPIM BY E.U.KIM</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, user-scalable=no"
    />
    <link rel="stylesheet" href="assets/css/main.css" />
    <noscript
      ><link rel="stylesheet" href="assets/css/noscript.css"
    /></noscript>
    <style>
       .input {
          width: 60px;
      }
      .label {
            font-size: 12px;
            color: gray;
        }
      .array {
          margin-bottom: 30px;
          
          padding: 10px;
      }

      .array-matrix {
          border-collapse: collapse;
          width: 100%;
      }

      .array-matrix td {
          border: 2px solid #ccc;
          padding: 20px;
          text-align: center;
      }
  </style>
   

  </head>
  <body class="is-preload">
    <!-- Wrapper -->
    <div id="wrapper">
      <!-- Header -->
      <header id="header">
        <a href="index.html" class="logo">RIPIM</a>
      </header>

      <!-- Nav -->
      <nav id="nav">
        <ul class="links">
          <li><a href="index.html">소개 | Introducion</a></li>
          <li><a href="rosua.html">개념 | RIP</a></li>
          <li><a href="algo.html">알고리즘 | Algo</a></li>
          <li class="active"><a href="imple.html">구현 | Implementation</a></li>
        </ul>
      </nav>

      <!-- Main -->
      <div id="main">
        <!-- Post -->
        <h2>구현하기</h2>

        <body>
          
          <label for="arrayCount">만들고 싶은 배열의 개수
          <input type="number" id="arrayCount" placeholder="배열 개수">
          <button onclick="createArrays()">Go</button></label>
      
          <div id="arraysContainer"></div>
      
          <label for="arrayName">루트 노드
          <input type="text" id="arrayName" placeholder="배열 이름">
          <button onclick="runDijkstra()">Go</button></label>
      
          <div id="result"></div>
      
          <script>
              let graph = {};
              let arrayCount = 0;
      
              // 다익스트라 결과를 배열로 변환하는 함수
              function distancesToArray(distances) {
                  const resultArray = [];
      
                  for (const vertex in distances) {
                      resultArray.push([vertex, distances[vertex]]);
                  }
      
                  return resultArray;
              }
      
              function createArrays() {
                  arrayCount = parseInt(document.getElementById('arrayCount').value);
                  graph = {};
                  const arraysContainer = document.getElementById('arraysContainer');
                  arraysContainer.innerHTML = '';
      
                  for (let i = 0; i < arrayCount; i++) {
                      const arrayName = String.fromCharCode(65 + i);
                      const arrayElement = document.createElement('div');
                      arrayElement.className = 'array';
      
                      const arrayLabel = document.createElement('p');
                      arrayLabel.textContent = arrayName + ' 배열';
      
                      const arrayMatrix = document.createElement('table');
                      arrayMatrix.className = 'array-matrix';
                      const row = document.createElement('tr');
                      for (let j = 0; j < arrayCount; j++) {
                          const cell = document.createElement('td');
                          const input = document.createElement('input');
                          input.type = 'text';
                          input.id = `array-${arrayName}-${String.fromCharCode(65 + j)}`;
                          if (j === i) {
                              input.value = '0'; // 해당 열에 대한 값은 0으로 고정
                              input.readOnly = true; // 읽기 전용 설정
                          } else {
                              input.value = '∞';
                          }
                          cell.appendChild(input);
                          row.appendChild(cell);
                      }
                      arrayMatrix.appendChild(row);
      
                      arrayElement.appendChild(arrayLabel);
                      arrayElement.appendChild(arrayMatrix);
                      arraysContainer.appendChild(arrayElement);
      
                      graph[arrayName] = {};
                  }
              }
      
              function runDijkstra() {
                  const arrayNameInput = document.getElementById('arrayName');
      
                  if (!arrayNameInput) {
                      alert("배열 이름 입력 요소를 찾을 수 없습니다.");
                      return;
                  }
      
                  const selectedArrayName = arrayNameInput.value.toUpperCase();
      
                  if (!(selectedArrayName in graph)) {
                      alert("유효한 배열 이름을 입력하세요.");
                      return;
                  }
      
                  for (let i = 0; i < arrayCount; i++) {
                      const sourceArrayName = String.fromCharCode(65 + i);
                      for (let j = 0; j < arrayCount; j++) {
                          const targetArrayName = String.fromCharCode(65 + j);
                          const inputElement = document.querySelector(`#array-${sourceArrayName}-${targetArrayName}`);
      
                          if (!inputElement) {
                              alert(`배열 ${sourceArrayName}의 입력 요소를 찾을 수 없습니다.`);
                              return;
                          }
      
                          const inputValue = inputElement.value;
                          const value = inputValue === '∞' ? Infinity : parseInt(inputValue);
                          graph[sourceArrayName][targetArrayName] = value;
                      }
                  }
      
                  const { distances, path } = dijkstra(graph, selectedArrayName);
      
                  console.log(`${selectedArrayName} 배열의 최단 거리 결과:`, distances);
                  const resultElement = document.getElementById('result');
      
                  // 수정된 부분: 최단 거리 결과와 경로 정보를 함께 출력
                  const resultArray = distancesToArray(distances);
                  resultElement.innerHTML = `<p>${selectedArrayName} 배열의 최단 거리 결과:</p>`;
                  for (const [vertex, distance] of resultArray) {
                      const pathInfo = getPathInfo(vertex, path);
                      resultElement.innerHTML += `<p>${vertex} -> ${distance} (${pathInfo})</p>`;
                  }
              }
      
              function dijkstra(graph, start) {
                  const dist = {};
                  const path = {};
                  const visited = {};
      
                  for (const vertex in graph) {
                      dist[vertex] = Infinity;
                      path[vertex] = null;
                      visited[vertex] = false;
                  }
      
                  dist[start] = 0;
      
                  for (let i = 0; i < arrayCount - 1; i++) {
                      const u = findMinDistVertex(dist, visited);
                      visited[u] = true;
      
                      for (const v in graph[u]) {
                          if (!visited[v] && dist[u] + graph[u][v] < dist[v]) {
                              dist[v] = dist[u] + graph[u][v];
                              path[v] = u;
                          }
                      }
                  }
      
                  return { distances: dist, path };
              }
      
              function findMinDistVertex(dist, visited) {
                  let minDist = Infinity;
                  let minVertex = null;
      
                  for (const vertex in dist) {
                      if (!visited[vertex] && dist[vertex] < minDist) {
                          minDist = dist[vertex];
                          minVertex = vertex;
                      }
                  }
      
                  return minVertex;
              }
      
              // 경로 정보를 생성하는 함수
              function getPathInfo(vertex, path) {
                  if (path[vertex] === null) {
                      return `${vertex}->${vertex}`;
                  }
      
                  let current = vertex;
                  let pathString = '';
      
                  while (path[current] !== null) {
                      pathString = `+${current}` + pathString;
                      current = path[current];
                  }
      
                  return `${vertex}->${current}${pathString}`;
              }
          </script>
      </body>
        </section>
      </div>

      <!-- Footer -->
      <footer id="footer">
        
            </ul>
          </section>
        </section>
      </footer>

       <!-- Copyright -->
	   <div id="copyright">
        <ul>
          <li>comedu</li>
          <li>RIPIM</li>
        </ul>
      </div>
    </div>

    <!-- Scripts -->
    <script src="assets/js/jquery.min.js"></script>
    <script src="assets/js/jquery.scrollex.min.js"></script>
    <script src="assets/js/jquery.scrolly.min.js"></script>
    <script src="assets/js/browser.min.js"></script>
    <script src="assets/js/breakpoints.min.js"></script>
    <script src="assets/js/util.js"></script>
    <script src="assets/js/main.js"></script>
  </body>
</html>
