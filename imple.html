<!DOCTYPE html>

<html>
  <head>
    <title>RIPIM BY E.U.KIM</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, user-scalable=no"
    />
    <link rel="stylesheet" href="assets/css/main.css" />
    <noscript
      ><link rel="stylesheet" href="assets/css/noscript.css"
    /></noscript>
    <style>
      .array {
          display: inline-block;
          margin: 30px;
      }
      input {
          width: 30px;
      }
      .label {
            font-size: 12px;
            color: gray;
        }
        .array-container {
            display: flex;
            flex-direction: row;
        }
        .selected-array {
            display: flex;
            flex-direction: row;
        }
  </style>
   

  </head>
  <body class="is-preload">
    <!-- Wrapper -->
    <div id="wrapper">
      <!-- Header -->
      <header id="header">
        <a href="index.html" class="logo">RIPIM</a>
      </header>

      <!-- Nav -->
      <nav id="nav">
        <ul class="links">
          <li><a href="index.html">소개 | Introducion</a></li>
          <li><a href="rosua.html">개념 | RIP</a></li>
          <li><a href="algo.html">알고리즘 | Algo</a></li>
          <li class="active"><a href="imple.html">구현 | Implementation</a></li>
        </ul>
        
      </nav>
      

      <!-- Main -->
      <div id="main">
        <!-- Post -->
        <h2>구현하기</h2>

        <body>
    <label for="arrayCount">만들고 싶은 배열의 개수를 입력하세요:
    <input type="number" id="arrayCount" min="1">
    <button onclick="createArrays()">배열 생성</button></label>
    
    <div id="arrayContainer"></div>
    
    <label for="selectArray">배열 선택:
    <select id="selectArray"></select>
    <button onclick="showSelectedArray()">배열 보기</button></label>
    
    <div id="selectedArray" class="array-container"></div>
    
    <div id="routingResult" class="array-container"></div>
    
    <div id="resultComment" class="comment"></div>
    
    <!-- 업데이트된 배열 보기 버튼 추가 -->
    <button onclick="showUpdatedArray()">업데이트된 배열 보기</button>
    
    <!-- 업데이트된 배열을 표시할 영역 추가 -->
    <div id="updatedArray" class="array-container"></div>
    
    <!-- 최종 결과 보기 버튼 추가 -->
    <button onclick="showFinalResult()">최종 결과 보기</button>
    
    <!-- 최종 결과를 표시할 영역 추가 -->
    <div id="finalResult" class="array-container"></div>
    
    <script>
        const arrays = []; // 배열 저장
        let updatedArray = null; // 업데이트된 배열 저장
        
        function createArrays() {
            const arrayCount = parseInt(document.getElementById("arrayCount").value);
            const arrayContainer = document.getElementById("arrayContainer");
            const selectArray = document.getElementById("selectArray");
            arrayContainer.innerHTML = ""; // 이전 내용 삭제
            selectArray.innerHTML = ""; // 드롭다운 목록 초기화
            
            for (let i = 0; i < arrayCount; i++) {
                const arrayDiv = document.createElement("div");
                arrayDiv.className = "array";
                
                const arrayLabel = document.createElement("label");
                arrayLabel.textContent = `${String.fromCharCode(65 + i)}배열`;
                arrayDiv.appendChild(arrayLabel);
                
                const array = [];
                for (let j = 0; j < arrayCount; j++) {
                    const input = document.createElement("input");
                    input.type = "number"; 
                    input.min = "0";
                    if (i === j) {
                        input.value = "0"; 
                    } else {
                        input.placeholder = "∞"; 
                    }
                    array.push(input);
                    arrayDiv.appendChild(input);
                }
                
                arrays.push(array);
                arrayContainer.appendChild(arrayDiv);
                
                // 드롭다운 목록 업데이트
                const option = document.createElement("option");
                option.value = String.fromCharCode(65 + i);
                option.textContent = `${String.fromCharCode(65 + i)}배열`;
                selectArray.appendChild(option);
            }
        }
        
        function showSelectedArray() {
            const selectArray = document.getElementById("selectArray");
            const selectedArrayDiv = document.getElementById("selectedArray");
            const routingResultDiv = document.getElementById("routingResult");
            const resultCommentDiv = document.getElementById("resultComment");
            const selectedArrayName = selectArray.value.toUpperCase();
            
            selectedArrayDiv.innerHTML = ""; // 이전 내용 삭제
            routingResultDiv.innerHTML = ""; // 이전 결과 삭제
            resultCommentDiv.innerHTML = ""; // 이전 코멘트 삭제
            
            for (let i = 0; i < arrays.length; i++) {
                if (String.fromCharCode(65 + i) === selectedArrayName) {
                    const selectedArray = arrays[i];
                    const resultArray = [];
                    for (let j = 0; j < selectedArray.length; j++) {
                        const input = document.createElement("input");
                        input.type = "number";
                        input.value = selectedArray[j].value;
                        selectedArrayDiv.appendChild(input);
                        resultArray.push(input);
                    }
                    applyRipAlgorithm(selectedArrayName, resultArray, routingResultDiv, resultCommentDiv);
                    break;
                }
            }
        }
        
        function applyRipAlgorithm(selectedArrayName, selectedArray, resultDiv, commentDiv) {
            const N = selectedArray.length;
            const distances = new Array(N).fill(null).map(() => new Array(N).fill(Infinity));
    
            for (let i = 0; i < N; i++) {
                for (let j = 0; j < N; j++) {
                    if (i === j) {
                        distances[i][j] = 0;
                    } else {
                        distances[i][j] = parseInt(selectedArray[j].value) || Infinity;
                    }
                }
            }
    
            const updateProcess = []; // 갱신 과정 초기화
    
            for (let k = 0; k < N; k++) {
                for (let i = 0; i < N; i++) {
                    for (let j = 0; j < N; j++) {
                        if (distances[i][k] + distances[k][j] < distances[i][j]) {
                            distances[i][j] = distances[i][k] + distances[k][j];
                            updateProcess.push(`${String.fromCharCode(65 + i)}열 -> ${String.fromCharCode(65 + j)}열: ${distances[i][j]}`);
                        }
                    }
                }
            }
    
            // 갱신 과정 표시
            for (let i = 0; i < updateProcess.length; i++) {
                const processDiv = document.createElement("div");
                processDiv.className = "comment";
                processDiv.textContent = updateProcess[i];
                commentDiv.appendChild(processDiv);
            }
    
            // 결과를 resultDiv에 표시
            for (let i = 0; i < N; i++) {
                const rowDiv = document.createElement("div");
                rowDiv.className = "array";
                for (let j = 0; j < N; j++) {
                    const input = document.createElement("input");
                    input.type = "text";
                    input.value = distances[i][j] === Infinity ? "∞" : distances[i][j].toString();
                    rowDiv.appendChild(input);
                }
                resultDiv.appendChild(rowDiv);
            }
    
            // 코멘트 표시
            const comment = document.createElement("div");
            comment.className = "comment";
            comment.textContent = `${selectedArrayName}배열의 열의 최단 거리 결과는 다음과 같습니다: ${distances[0].join(', ')}`;
            commentDiv.appendChild(comment);
    
            // 업데이트된 배열 저장
            updatedArray = distances;
        }
        
        // 업데이트된 배열 보기
        function showUpdatedArray() {
            const updatedArrayDiv = document.getElementById("updatedArray");
            updatedArrayDiv.innerHTML = ""; // 이전 내용 삭제
            
            if (updatedArray) {
                for (let i = 0; i < updatedArray.length; i++) {
                    const rowDiv = document.createElement("div");
                    rowDiv.className = "array";
                    for (let j = 0; j < updatedArray[i].length; j++) {
                        const input = document.createElement("input");
                        input.type = "text";
                        input.value = updatedArray[i][j] === Infinity ? "∞" : updatedArray[i][j].toString();
                        rowDiv.appendChild(input);
                    }
                    updatedArrayDiv.appendChild(rowDiv);
                }
            } else {
                const noDataMessage = document.createElement("div");
                noDataMessage.className = "comment";
                noDataMessage.textContent = "갱신된 배열이 아직 없습니다. 먼저 RIP 알고리즘을 실행하세요.";
                updatedArrayDiv.appendChild(noDataMessage);
            }
        }
        
        // 최종 결과 보기
        function showFinalResult() {
            const finalResultDiv = document.getElementById("finalResult");
            finalResultDiv.innerHTML = ""; // 이전 내용 삭제
            
            if (updatedArray) {
                for (let i = 0; i < updatedArray.length; i++) {
                    const rowDiv = document.createElement("div");
                    rowDiv.className = "array";
                    for (let j = 0; j < updatedArray[i].length; j++) {
                        const input = document.createElement("input");
                        input.type = "text";
                        input.value = updatedArray[i][j] === Infinity ? "∞" : updatedArray[i][j].toString();
                        rowDiv.appendChild(input);
                    }
                    finalResultDiv.appendChild(rowDiv);
                }
            } else {
                const noDataMessage = document.createElement("div");
                noDataMessage.className = "comment";
                noDataMessage.textContent = "갱신된 배열이 아직 없습니다. 먼저 RIP 알고리즘을 실행하세요.";
                finalResultDiv.appendChild(noDataMessage);
            }
        }
    </script>
</body>
        </section>
      </div>

      <!-- Footer -->
      <footer id="footer">
        
            </ul>
          </section>
        </section>
      </footer>

       <!-- Copyright -->
	   <div id="copyright">
        <ul>
          <li>comedu</li>
          <li>RIPIM</li>
        </ul>
      </div>
    </div>

    <!-- Scripts -->
    <script src="assets/js/jquery.min.js"></script>
    <script src="assets/js/jquery.scrollex.min.js"></script>
    <script src="assets/js/jquery.scrolly.min.js"></script>
    <script src="assets/js/browser.min.js"></script>
    <script src="assets/js/breakpoints.min.js"></script>
    <script src="assets/js/util.js"></script>
    <script src="assets/js/main.js"></script>
  </body>
</html>
